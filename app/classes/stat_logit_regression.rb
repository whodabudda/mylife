class StatLogitRegression < StatRegressionBase
    include StatAssumptions
    def initialize(review,ss) 
        super(review,ss)
    end

    #
    #
    def who_am_i
        "This is a chart showing a possible relationship between #{review.metric.name} and #{review.event.name}.
        The horizontal values (x-values) are the values for #{review.metric.name}, measured
        between #{review.start_dt} and #{review.end_dt}.
        There is a data point for each #{span_hours} hour segement that has data.
        The y (vertical) value is the probability that #{review.event.name} occured within #{span_hours} hours of #{review.metric.name}.
        If the line slants up, it can be inferred that as #{review.metric.name} increases, it is more likely
        that #{review.event.name} occured. If the line slants down, then less likely.
        The p-value is essentially an indicator as to how reliable the data is.  If it is greater than .05, it is generally considered to be statistically insignificant.
        "
    end
    def perform_analysis
        #most regression charts will have more than one series. The chartSeries
        #variable is an array of hashes, where each element in the array has the hash elements
        #for a series.  Regression charts have a scatter graph series, and a line graph series.
        #We keep track of which series this object occupies by assigning it an index and 
        #writing its Highcharts elements to chartSeries[ndx].
        ndx = chartSeries.length  #ndx of the next empty slot
        #if the class name doesn't exist as an element in the existing hashes, start a new one 
        #with this class name, otherwise assign the index of the the discovered hash to ndx.
        if chartSeries.index {|h| h[:name] == self.class.name }.nil? 
            chartSeries[ndx] = {id: self.class.name}
        else
            ndx = chartSeries.index {|h| h[:name] == self.class.name }
        end

        Rails.logger.info "#{self.class.name}:#{__method__} --  Index is: #{ndx} and chartSeries is: #{chartSeries[ndx]} "
        #get the data for the series
        getDataArray
        #set other values for the series
        #setSingleValues(ndx)
        #chartSeries.push(getRegValues(ndx))  #create the series for the regression line
    end


    def checkAssumptions

        validData? && (isLogistical? || unary_regression?)
    end

private

def getDataArray
  #debugger
    #The 'event' is usually the x axis, however for logical regression, the y axis is used for the logit data, i.e. it is either true or false,something that either happened or did not happen.  If all values are the same, we can format them to conform with the logit requirements. For example, did the event happen within the timeframe? assign a 1, otherwise assign a zero.   
  Rails.logger.info "#{self.class.name}:#{__method__} --  dataset size #{dataset.size} "
  @events = []
  values = []

  dataset.each do |rec|
    if (rec.metric_id == review.event_id) 
      @events.push rec
    else
      values.concat ( formatPoint(rec))    
    end
  end
  #values is the array of hashes containing x:y 
  #Rails.logger.info "#{self.class.name}:#{__method__} -- series data:  #{values} "
  Rails.logger.info "#{self.class.name}:#{__method__} -- created  #{values.length} points"
  #need to convert the array into 2 separate vectors to pass to the function doing the R test 
  vx = values.map {|row| row[:x]} 
  vy = values.map {|row| row[:y]} 
  #The function sets the chartImageFile variable in StatSample for use by the view.
  #This file contains the logical regression image generated by the R server.
  logit_regression(vx,vy)
  after_analysis_review(vx,vy)
end

def after_analysis_review(vx,vy)
    independent_observations(vx,vy)
end

    #format the point data for highcharts to use. 
    #For regressions, the y value is the metric, the x value the event.
    #All metrics and events have numeric values
    #return a hash useable by highcharts in its :data array

    #accumulate and average the events within the span window, so instead of a point for
    #every event, we'll have a point of the event average for every cluster of events 
    #within the window. 
def formatPoint(metric)
  values = []
  #Rails.logger.info "#{self.class.name}:#{__method__} -- event count: #{@events.length} metric(id,value): #{metric.id},#{metric.value}"
  remove_me = []
  event_cnt = 0
  # loop through events that led up to the metric.
  # if an event is within the time frame, add to the count 
  @events.each do |rec|
    hours = 0
    hours = ((metric.occur_dttm - rec.occur_dttm)/3600).to_i if rec.metric_id == review.event_id
    #puts "rec.id: #{rec.id}  hours: #{ hours}  "
    if hours > @span_hours
       # puts "adding event #{rec.id} to remove_me list"
        remove_me.push rec
    else
       # puts "adding event #{rec.id} with #{hours} hours"
       event_cnt += 1
    end
  end
#clean up events.  Don't know if its really necessary.
# @events = @events - remove_me
  @events = []
      
  #add a point for each event counted as being in the date range of the current metric.
  #for logistic regression, the y value is always 0 or 1.  So in this case, create a point for 
  #every event in range, with a y value of 1.  Otherwise,create one point with a y value of 0.
  (0..event_cnt).each { |i| values.push point = {"x": metric.value , "y": (i == 0 ? 0:1) } }
  return values
end
end